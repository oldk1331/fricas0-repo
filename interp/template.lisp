 
; )package "BOOT"
 
(IN-PACKAGE "BOOT")
 
; getOperationAlistFromLisplib x ==
;   u := GETDATABASE(x, 'OPERATIONALIST)
; --  u := removeZeroOneDestructively u
;   null u => u          -- this can happen for Object
;   CAAR u = '_$unique => rest u
;   f:= addConsDB '(NIL T ELT)
;   for [op,:sigList] in u repeat
;     for items in tails sigList repeat
;       [sig,:r] := first items
;       if r is [.,:s] then
;         if s is [.,:t] then
;           if t is [.] then nil
;           else RPLACD(s,QCDDR f)
;         else RPLACD(r,QCDR f)
;       else RPLACD(first items,f)
;       RPLACA(items, addConsDB first items)
;   u and markUnique u
 
(DEFUN |getOperationAlistFromLisplib| (|x|)
  (PROG (|u| |f| |op| |sigList| |LETTMP#1| |sig| |r| |s| |t|)
    (RETURN
     (PROGN
      (SETQ |u| (GETDATABASE |x| 'OPERATIONALIST))
      (COND ((NULL |u|) |u|) ((EQ (CAAR |u|) '|$unique|) (CDR |u|))
            (#1='T
             (PROGN
              (SETQ |f| (|addConsDB| '(NIL T ELT)))
              ((LAMBDA (|bfVar#2| |bfVar#1|)
                 (LOOP
                  (COND
                   ((OR (ATOM |bfVar#2|)
                        (PROGN (SETQ |bfVar#1| (CAR |bfVar#2|)) NIL))
                    (RETURN NIL))
                   (#1#
                    (AND (CONSP |bfVar#1|)
                         (PROGN
                          (SETQ |op| (CAR |bfVar#1|))
                          (SETQ |sigList| (CDR |bfVar#1|))
                          #1#)
                         ((LAMBDA (|items|)
                            (LOOP
                             (COND ((ATOM |items|) (RETURN NIL))
                                   (#1#
                                    (PROGN
                                     (SETQ |LETTMP#1| (CAR |items|))
                                     (SETQ |sig| (CAR |LETTMP#1|))
                                     (SETQ |r| (CDR |LETTMP#1|))
                                     (COND
                                      ((AND (CONSP |r|)
                                            (PROGN (SETQ |s| (CDR |r|)) #1#))
                                       (COND
                                        ((AND (CONSP |s|)
                                              (PROGN (SETQ |t| (CDR |s|)) #1#))
                                         (COND
                                          ((AND (CONSP |t|) (EQ (CDR |t|) NIL))
                                           NIL)
                                          (#1# (RPLACD |s| (QCDDR |f|)))))
                                        (#1# (RPLACD |r| (QCDR |f|)))))
                                      (#1# (RPLACD (CAR |items|) |f|)))
                                     (RPLACA |items|
                                             (|addConsDB| (CAR |items|))))))
                             (SETQ |items| (CDR |items|))))
                          |sigList|))))
                  (SETQ |bfVar#2| (CDR |bfVar#2|))))
               |u| NIL)
              (AND |u| (|markUnique| |u|)))))))))
 
; markUnique x ==
;   u := first x
;   RPLACA(x,'(_$unique))
;   RPLACD(x,[u,:rest x])
;   rest x
 
(DEFUN |markUnique| (|x|)
  (PROG (|u|)
    (RETURN
     (PROGN
      (SETQ |u| (CAR |x|))
      (RPLACA |x| '(|$unique|))
      (RPLACD |x| (CONS |u| (CDR |x|)))
      (CDR |x|)))))
 
; addConsDB x == x
 
(DEFUN |addConsDB| (|x|) (PROG () (RETURN |x|)))
 
; NRTdescendCodeTran(u,condList) ==
; --NRTbuildFunctor calls to fill $template slots with names of compiled functions
;   null u => nil
;   u is ['LIST] => nil
;   u is [op,.,i,a] and MEMQ(op,'(SETELT QSETREFV)) =>
;     null condList and a is ['CONS,fn,:.] =>
;       RPLACA(u,'LIST)
;       RPLACD(u,nil)
;       $template.i :=
;         fn = 'IDENTITY => a
;         fn is ['dispatchFunction,fn'] => fn'
;         fn
;     a is ['CONS, 'IDENTITY, ['FUNCALL, fn, "$"]] =>
;         na := [['FUNCTION, 'makeSpadConstant], ["LIST", fn, "$", i]]
;         RPLACD(a, na)
;         nil
;     nil   --code for this will be generated by the instantiator
;   u is ['COND,:c] =>
;     for [pred,:y] in c|y repeat NRTdescendCodeTran(first y,[pred,:condList])
;   u is ['PROGN,:c] => for x in c repeat NRTdescendCodeTran(x,condList)
;   nil
 
(DEFUN |NRTdescendCodeTran| (|u| |condList|)
  (PROG (|op| |ISTMP#1| |ISTMP#2| |i| |ISTMP#3| |a| |fn| |fn'| |ISTMP#4|
         |ISTMP#5| |na| |c| |pred| |y|)
    (RETURN
     (COND ((NULL |u|) NIL)
           ((AND (CONSP |u|) (EQ (CDR |u|) NIL) (EQ (CAR |u|) 'LIST)) NIL)
           ((AND (CONSP |u|)
                 (PROGN
                  (SETQ |op| (CAR |u|))
                  (SETQ |ISTMP#1| (CDR |u|))
                  (AND (CONSP |ISTMP#1|)
                       (PROGN
                        (SETQ |ISTMP#2| (CDR |ISTMP#1|))
                        (AND (CONSP |ISTMP#2|)
                             (PROGN
                              (SETQ |i| (CAR |ISTMP#2|))
                              (SETQ |ISTMP#3| (CDR |ISTMP#2|))
                              (AND (CONSP |ISTMP#3|) (EQ (CDR |ISTMP#3|) NIL)
                                   (PROGN
                                    (SETQ |a| (CAR |ISTMP#3|))
                                    #1='T)))))))
                 (MEMQ |op| '(SETELT QSETREFV)))
            (COND
             ((AND (NULL |condList|) (CONSP |a|) (EQ (CAR |a|) 'CONS)
                   (PROGN
                    (SETQ |ISTMP#1| (CDR |a|))
                    (AND (CONSP |ISTMP#1|)
                         (PROGN (SETQ |fn| (CAR |ISTMP#1|)) #1#))))
              (PROGN
               (RPLACA |u| 'LIST)
               (RPLACD |u| NIL)
               (SETF (ELT |$template| |i|)
                       (COND ((EQ |fn| 'IDENTITY) |a|)
                             ((AND (CONSP |fn|)
                                   (EQ (CAR |fn|) '|dispatchFunction|)
                                   (PROGN
                                    (SETQ |ISTMP#1| (CDR |fn|))
                                    (AND (CONSP |ISTMP#1|)
                                         (EQ (CDR |ISTMP#1|) NIL)
                                         (PROGN
                                          (SETQ |fn'| (CAR |ISTMP#1|))
                                          #1#))))
                              |fn'|)
                             (#1# |fn|)))))
             ((AND (CONSP |a|) (EQ (CAR |a|) 'CONS)
                   (PROGN
                    (SETQ |ISTMP#1| (CDR |a|))
                    (AND (CONSP |ISTMP#1|) (EQ (CAR |ISTMP#1|) 'IDENTITY)
                         (PROGN
                          (SETQ |ISTMP#2| (CDR |ISTMP#1|))
                          (AND (CONSP |ISTMP#2|) (EQ (CDR |ISTMP#2|) NIL)
                               (PROGN
                                (SETQ |ISTMP#3| (CAR |ISTMP#2|))
                                (AND (CONSP |ISTMP#3|)
                                     (EQ (CAR |ISTMP#3|) 'FUNCALL)
                                     (PROGN
                                      (SETQ |ISTMP#4| (CDR |ISTMP#3|))
                                      (AND (CONSP |ISTMP#4|)
                                           (PROGN
                                            (SETQ |fn| (CAR |ISTMP#4|))
                                            (SETQ |ISTMP#5| (CDR |ISTMP#4|))
                                            (AND (CONSP |ISTMP#5|)
                                                 (EQ (CDR |ISTMP#5|) NIL)
                                                 (EQ (CAR |ISTMP#5|)
                                                     '$))))))))))))
              (PROGN
               (SETQ |na|
                       (LIST (LIST 'FUNCTION '|makeSpadConstant|)
                             (LIST 'LIST |fn| '$ |i|)))
               (RPLACD |a| |na|)
               NIL))
             (#1# NIL)))
           ((AND (CONSP |u|) (EQ (CAR |u|) 'COND)
                 (PROGN (SETQ |c| (CDR |u|)) #1#))
            ((LAMBDA (|bfVar#4| |bfVar#3|)
               (LOOP
                (COND
                 ((OR (ATOM |bfVar#4|)
                      (PROGN (SETQ |bfVar#3| (CAR |bfVar#4|)) NIL))
                  (RETURN NIL))
                 (#1#
                  (AND (CONSP |bfVar#3|)
                       (PROGN
                        (SETQ |pred| (CAR |bfVar#3|))
                        (SETQ |y| (CDR |bfVar#3|))
                        #1#)
                       |y|
                       (|NRTdescendCodeTran| (CAR |y|)
                        (CONS |pred| |condList|)))))
                (SETQ |bfVar#4| (CDR |bfVar#4|))))
             |c| NIL))
           ((AND (CONSP |u|) (EQ (CAR |u|) 'PROGN)
                 (PROGN (SETQ |c| (CDR |u|)) #1#))
            ((LAMBDA (|bfVar#5| |x|)
               (LOOP
                (COND
                 ((OR (ATOM |bfVar#5|) (PROGN (SETQ |x| (CAR |bfVar#5|)) NIL))
                  (RETURN NIL))
                 (#1# (|NRTdescendCodeTran| |x| |condList|)))
                (SETQ |bfVar#5| (CDR |bfVar#5|))))
             |c| NIL))
           (#1# NIL)))))
 
; NRTaddInner x ==
; --called by genDeltaEntry and others that affect $NRTdeltaList
;   PROGN
;     atom x => nil
;     x is ['Record,:l] =>
;       for [.,.,y] in l repeat NRTinnerGetLocalIndex y
;     first x in '(Union Mapping) =>
;       for y in rest x repeat
;          y is [":",.,z] => NRTinnerGetLocalIndex z
;          NRTinnerGetLocalIndex y
;     x is ['SubDomain,y,:.] => NRTinnerGetLocalIndex y
;     getConstructorSignature x is [.,:ml] =>
;       for y in rest x for m in ml | not (y = '$) repeat
;         isCategoryForm(m,$CategoryFrame) => NRTinnerGetLocalIndex y
;     keyedSystemError("S2NR0003",[x])
;   x
 
(DEFUN |NRTaddInner| (|x|)
  (PROG (|l| |ISTMP#1| |ISTMP#2| |y| |z| |ml|)
    (RETURN
     (PROGN
      (COND ((ATOM |x|) NIL)
            ((AND (CONSP |x|) (EQ (CAR |x|) '|Record|)
                  (PROGN (SETQ |l| (CDR |x|)) #1='T))
             ((LAMBDA (|bfVar#7| |bfVar#6|)
                (LOOP
                 (COND
                  ((OR (ATOM |bfVar#7|)
                       (PROGN (SETQ |bfVar#6| (CAR |bfVar#7|)) NIL))
                   (RETURN NIL))
                  (#1#
                   (AND (CONSP |bfVar#6|)
                        (PROGN
                         (SETQ |ISTMP#1| (CDR |bfVar#6|))
                         (AND (CONSP |ISTMP#1|)
                              (PROGN
                               (SETQ |ISTMP#2| (CDR |ISTMP#1|))
                               (AND (CONSP |ISTMP#2|) (EQ (CDR |ISTMP#2|) NIL)
                                    (PROGN (SETQ |y| (CAR |ISTMP#2|)) #1#)))))
                        (|NRTinnerGetLocalIndex| |y|))))
                 (SETQ |bfVar#7| (CDR |bfVar#7|))))
              |l| NIL))
            ((|member| (CAR |x|) '(|Union| |Mapping|))
             ((LAMBDA (|bfVar#8| |y|)
                (LOOP
                 (COND
                  ((OR (ATOM |bfVar#8|) (PROGN (SETQ |y| (CAR |bfVar#8|)) NIL))
                   (RETURN NIL))
                  (#1#
                   (COND
                    ((AND (CONSP |y|) (EQ (CAR |y|) '|:|)
                          (PROGN
                           (SETQ |ISTMP#1| (CDR |y|))
                           (AND (CONSP |ISTMP#1|)
                                (PROGN
                                 (SETQ |ISTMP#2| (CDR |ISTMP#1|))
                                 (AND (CONSP |ISTMP#2|)
                                      (EQ (CDR |ISTMP#2|) NIL)
                                      (PROGN
                                       (SETQ |z| (CAR |ISTMP#2|))
                                       #1#))))))
                     (|NRTinnerGetLocalIndex| |z|))
                    (#1# (|NRTinnerGetLocalIndex| |y|)))))
                 (SETQ |bfVar#8| (CDR |bfVar#8|))))
              (CDR |x|) NIL))
            ((AND (CONSP |x|) (EQ (CAR |x|) '|SubDomain|)
                  (PROGN
                   (SETQ |ISTMP#1| (CDR |x|))
                   (AND (CONSP |ISTMP#1|)
                        (PROGN (SETQ |y| (CAR |ISTMP#1|)) #1#))))
             (|NRTinnerGetLocalIndex| |y|))
            ((PROGN
              (SETQ |ISTMP#1| (|getConstructorSignature| |x|))
              (AND (CONSP |ISTMP#1|) (PROGN (SETQ |ml| (CDR |ISTMP#1|)) #1#)))
             ((LAMBDA (|bfVar#9| |y| |bfVar#10| |m|)
                (LOOP
                 (COND
                  ((OR (ATOM |bfVar#9|) (PROGN (SETQ |y| (CAR |bfVar#9|)) NIL)
                       (ATOM |bfVar#10|)
                       (PROGN (SETQ |m| (CAR |bfVar#10|)) NIL))
                   (RETURN NIL))
                  (#1#
                   (AND (NULL (EQ |y| '$))
                        (COND
                         ((|isCategoryForm| |m| |$CategoryFrame|)
                          (IDENTITY (|NRTinnerGetLocalIndex| |y|)))))))
                 (SETQ |bfVar#9| (CDR |bfVar#9|))
                 (SETQ |bfVar#10| (CDR |bfVar#10|))))
              (CDR |x|) NIL |ml| NIL))
            (#1# (|keyedSystemError| 'S2NR0003 (LIST |x|))))
      |x|))))
 
; NRTinnerGetLocalIndex x ==
;   atom x => x
;   -- following test should skip Unions, Records, Mapping
;   MEMQ(opOf x,'(Union Record Mapping)) => NRTgetLocalIndex x
;   constructor?(x) => NRTgetLocalIndex x
;   NRTaddInner x
 
(DEFUN |NRTinnerGetLocalIndex| (|x|)
  (PROG ()
    (RETURN
     (COND ((ATOM |x|) |x|)
           ((MEMQ (|opOf| |x|) '(|Union| |Record| |Mapping|))
            (|NRTgetLocalIndex| |x|))
           ((|constructor?| |x|) (|NRTgetLocalIndex| |x|))
           ('T (|NRTaddInner| |x|))))))
 
; makeSpadConstant [fn,dollar,slot] ==
;   val := FUNCALL(fn,dollar)
;   u:= dollar.slot
;   RPLACA(u,function IDENTITY)
;   RPLACD(u,val)
;   val
 
(DEFUN |makeSpadConstant| (|bfVar#11|)
  (PROG (|fn| |dollar| |slot| |val| |u|)
    (RETURN
     (PROGN
      (SETQ |fn| (CAR |bfVar#11|))
      (SETQ |dollar| (CADR . #1=(|bfVar#11|)))
      (SETQ |slot| (CADDR . #1#))
      (SETQ |val| (FUNCALL |fn| |dollar|))
      (SETQ |u| (ELT |dollar| |slot|))
      (RPLACA |u| #'IDENTITY)
      (RPLACD |u| |val|)
      |val|))))
